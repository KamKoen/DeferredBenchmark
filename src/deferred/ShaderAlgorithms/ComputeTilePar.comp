#version 430


//
//Der Shader hier ist sehr gro�, weil hier alle m�glichen Unterteilungen beachtet werden, 
//und da immer mit anderen Werten gerechnet werden muss, m�sste man entweder mehrere
//Shader schreiben, oder mit if Abfragen arbeiten
//
//


layout(std430, binding = 1)  buffer zBuf
{
	float zB[]; //min max
};

layout(std430, binding = 4)  buffer infB
{
	int info[];
};

layout(std430, binding = 5)  buffer indB
{
	int indexB[];
};


layout(std430, binding = 6)  buffer infSubB
{
	int infoSub[];
};

layout(std430, binding = 7)  buffer indSubB
{
	int indexSub[];
};

layout(std430, binding = 2)  buffer infSubB2
{
	int infoSub2[];
};

layout(std430, binding = 3)  buffer indSubB2
{
	int indexSub2[];
};


uniform int zCulling = 0;

uniform int MAX_LIGHT_PER_TILE;
uniform int width;
uniform int height;

uniform int tileWidth;
uniform int tileHeight;

uniform int tileWidthSub;
uniform int tileHeightSub;

uniform int tileWidthSub2;
uniform int tileHeightSub2;

uniform float C;
uniform float D;

uniform int mode;

uniform mat4 invProj;
uniform mat4 view;

struct PointLight{

	vec4 position;	//.w is rad
	vec4 ambient;	//.w ist quad
	vec4 diff;		//.w ist lin
	vec4 specular;	//.w ist const
};

layout (std140) uniform pl{
	
	PointLight pLight[1000];

};

shared uint count;	
uniform int LIGHT_MAX;

layout(local_size_x = 256,local_size_y = 1,local_size_z = 1) in; 


vec4 createPlaneEq(vec4 a, vec4 b)
{


	vec4 n;
	
	n.xyz = normalize(cross(a.xyz, b.xyz));
	
	n.w = 0;
	
	return n;
	
}


float getSignedDistance(vec4 eqn, vec3 p)
{

	vec4 ret = view * vec4(p,1.0);
	
	float f = dot(eqn, ret);
	
	return f;

}


float calcViewZ(float z)
{
	float nDcz = z * 2.0 - 1.0;
	
	float res = -D / (nDcz + C);


	return res;
}







void createFrustumForTile()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;
	
	float x = curx * tileWidth;
	float x2 = x + tileWidth -1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeight;
	float y2 = y + tileHeight - 1;
	if(y2 > height-1) y2 = height-1;
	
	vec4 frustum[4];
	vec4 frustumEq[4];
	
	frustum[0] = vec4(
					2.0 * (x / width) - 1.0,
					2.0 * (y / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[1] = vec4(
					2.0 * (x2 / width) - 1.0,
					2.0 * (y / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[2] = vec4(
					2.0 * (x2 / width) - 1.0,
					2.0 * (y2 / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[3] = vec4(
					2.0 * (x / width) - 1.0,
					2.0 * (y2 / height) - 1.0,
					1.0,
					1.0
					);				
	
	
	for(int i = 0; i < 4; i++)
	{
			
		frustum[i] = invProj * frustum[i];
		frustum[i] /= frustum[i].w;
			
	}
	
	
	frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
	frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
	frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
	frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
	

	
	
	
	
	
	
	int offset = int(cury *( (width/tileWidth) * MAX_LIGHT_PER_TILE) 
			+ curx * MAX_LIGHT_PER_TILE);
	
	for(int i = 0; i < 4; i++)
	{
		int j = i * 256 + int(gl_LocalInvocationID.x);
		//int j = int(gl_LocalInvocationID.x);
		if( j > LIGHT_MAX-1) break;
		
		if	(
			
			(getSignedDistance(frustumEq[0], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[1], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[2], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[3], pLight[j].position.xyz) < pLight[j].position.w) 
			&& ((view * vec4(pLight[j].position.xyz,1)).z <= (0 + pLight[j].position.w))
			)
			{
				
				if(zCulling == 1)
				{
					int offsetZB = int(cury*(width/tileWidth) * 2 + curx * 2);
					
					if	(
						(view * vec4(pLight[j].position.xyz,1)).z <= (zB[offsetZB] + pLight[j].position.w)&&
						(view * vec4(pLight[j].position.xyz,1)).z >= (zB[offsetZB+1] - pLight[j].position.w)
						)
					{
						
						int tempCount = int(atomicAdd(count,1));
						barrier();
						
						indexB[offset + tempCount] = j;
						
						
					}
					
				
				
				}
				else
				{
				
					
					int tempCount = int(atomicAdd(count,1));
					barrier();					
					indexB[offset + tempCount] = j;		
					
				
				}
			}
		
		
		
	
	
	}
	
	groupMemoryBarrier();
	
	if(count > 0)
	{
					 	
		info[(curx + cury * (width/tileWidth)) * 2] = offset; //offset
		info[(curx + cury * (width/tileWidth)) * 2 + 1] = int(count); //
	
	}
	
	else
	{
		info[(curx + cury * (width/tileWidth)) * 2] = -1;
		info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
	
	}
	

}































void createFrustumForTileSub1() //mode 1
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidthSub;
	float x2 = x + tileWidthSub -1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeightSub;
	float y2 = y + tileHeightSub-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	
	vec4 frustum[4];
	vec4 frustumEq[4];
	
	frustum[0] = vec4(
					2.0 * (x / width) - 1.0,
					2.0 * (y / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[1] = vec4(
					2.0 * (x2 / width) - 1.0,
					2.0 * (y / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[2] = vec4(
					2.0 * (x2 / width) - 1.0,
					2.0 * (y2 / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[3] = vec4(
					2.0 * (x / width) - 1.0,
					2.0 * (y2 / height) - 1.0,
					1.0,
					1.0
					);				
	
	
	for(int i = 0; i < 4; i++)
	{
			
		frustum[i] = invProj * frustum[i];
		frustum[i] /= frustum[i].w;
			
	}
	
	
	frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
	frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
	frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
	frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
	
//	int count = 0;
	
	
	
	
	
	
	int offset = int(cury *( (width/tileWidthSub) * MAX_LIGHT_PER_TILE) 
			+ curx * MAX_LIGHT_PER_TILE);
	
	for(int i = 0; i < 4; i++)
	{
		int j = i * 256 + int(gl_LocalInvocationID.x);
		//int j = int(gl_LocalInvocationID.x);
		if( j > LIGHT_MAX-1) break;
		
		if	(
			
			(getSignedDistance(frustumEq[0], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[1], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[2], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[3], pLight[j].position.xyz) < pLight[j].position.w) 
			&& ((view * vec4(pLight[j].position.xyz,1)).z <= (0 + pLight[j].position.w))
			
			)
			{
			
			
					
					int tempCount = int(atomicAdd(count,1));
					barrier();
					indexSub[offset + tempCount] = j;
				
							
					
				
				
				
			
			
			}
		
		
		
	
	
	}
	
	groupMemoryBarrier();
	if(count > 0)
	{
					 	
		infoSub[(curx + cury * (width/tileWidthSub)) * 2] = offset; //offset
		infoSub[(curx + cury * (width/tileWidthSub)) * 2 + 1] = int(count); //
	
	}
	
	else
	{
		infoSub[(curx + cury * (width/tileWidthSub)) * 2] = -1;
		infoSub[(curx + cury * (width/tileWidthSub)) * 2 + 1] = -1;
	
	}
	

}



void createFrustumForTileSubWith2()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidthSub2;
	float x2 = x + tileWidthSub2-1;
	if(x2 > width -1) x2 = width -1;
	
	float y = cury * tileHeightSub2;
	float y2 = y + tileHeightSub2-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	
	vec4 frustum[4];
	vec4 frustumEq[4];
	
	frustum[0] = vec4(
					2.0 * (x / width) - 1.0,
					2.0 * (y / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[1] = vec4(
					2.0 * (x2 / width) - 1.0,
					2.0 * (y / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[2] = vec4(
					2.0 * (x2 / width) - 1.0,
					2.0 * (y2 / height) - 1.0,
					1.0,
					1.0
					);
					
	frustum[3] = vec4(
					2.0 * (x / width) - 1.0,
					2.0 * (y2 / height) - 1.0,
					1.0,
					1.0
					);				
	
	
	for(int i = 0; i < 4; i++)
	{
			
		frustum[i] = invProj * frustum[i];
		frustum[i] /= frustum[i].w;
			
	}
	
	
	frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
	frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
	frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
	frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
	
	//int count = 0;
	
	
	
	
	
	
	int offset = int(cury *( (width/tileWidthSub2) * MAX_LIGHT_PER_TILE) 
			+ curx * MAX_LIGHT_PER_TILE);
	
	for(int i = 0; i < 4; i++)
	{
		int j = i * 256 + int(gl_LocalInvocationID.x);
		//int j = int(gl_LocalInvocationID.x);
		if( j > LIGHT_MAX-1) break;
		
		
		if	(
			
			(getSignedDistance(frustumEq[0], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[1], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[2], pLight[j].position.xyz) < pLight[j].position.w) &&
			(getSignedDistance(frustumEq[3], pLight[j].position.xyz) < pLight[j].position.w) 
			&& ((view * vec4(pLight[j].position.xyz,1)).z <= (0 + pLight[j].position.w))
			)
			{
			
			
				int tempCount = int(atomicAdd(count,1));
				barrier();
				indexSub2[offset + tempCount] = j;
							
				
			}
		
		
		
	
	
	}
	

	if(count > 0)
	{
					 	
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = offset; //offset
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = int(count); //
	
	}
	
	else
	{
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
	
	}
	

}




void createFrustumForTileSub2after1()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidthSub2;
	float x2 = x + tileWidthSub2 - 1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeightSub2;
	float y2 = y + tileHeightSub2 - 1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	//what tile
	
	int curySub = int(y2 / tileHeightSub);
	int curxSub = int(x2 / tileWidthSub);
	
	int offsetSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2];
	int countSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2 + 1];
	
	if(offsetSub < 0) 
	{
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
	
	}
	else 
	{
		
		
		
		vec4 frustum[4];
		vec4 frustumEq[4];
		
		frustum[0] = vec4(
						2.0 * (x / width) - 1.0,
						2.0 * (y / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[1] = vec4(
						2.0 * (x2 / width) - 1.0,
						2.0 * (y / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[2] = vec4(
						2.0 * (x2 / width) - 1.0,
						2.0 * (y2 / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[3] = vec4(
						2.0 * (x / width) - 1.0,
						2.0 * (y2 / height) - 1.0,
						1.0,
						1.0
						);				
		
		
		for(int i = 0; i < 4; i++)
		{
				
			frustum[i] = invProj * frustum[i];
			frustum[i] /= frustum[i].w;
				
		}
		
		
		frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
		frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
		frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
		frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
		
	//	int count = 0;
		
		
		
		
		int i = 0;
		
		int offset = int(cury *( (width/tileWidthSub2) * MAX_LIGHT_PER_TILE) 
				+ curx * MAX_LIGHT_PER_TILE);
		
		for(int j = 0; j < countSub; j++)
		{
		
			int t = j * 256 + int(gl_LocalInvocationID.x);
			if(t >= countSub) break;
			i = indexSub[offsetSub + t];
			
			
			
			if	(
				
				(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w)  
				&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
				)
				{
					int tempCount = int(atomicAdd(count,1));
					barrier();
					indexSub2[offset + tempCount] = i;		
					
					
				}
			
			
			
		
		
		}
		
	
		if(count > 0)
		{
						 	
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = offset; //offset
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = int(count); //
		
		}
		
		else
		{
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
		
		}
	}

}






void createFrustumForTileFromSub2()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidth;
	float x2 = x + tileWidth-1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeight;
	float y2 = y + tileHeight-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	//what tile
	
	int curySub = int(y2 / tileHeightSub2);
	int curxSub = int(x2 / tileWidthSub2);
	
	int offsetSub = infoSub2[(curxSub + curySub * (width / tileWidthSub2)) * 2];
	int countSub = infoSub2[(curxSub + curySub * (width / tileWidthSub2)) * 2 + 1];
	
	if(offsetSub < 0) 
	{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
	
	}
	else 
	{
		
		
		
		vec4 frustum[4];
		vec4 frustumEq[4];
		
		frustum[0] = vec4(
						2.0 * (x / width) - 1.0,
						2.0 * (y / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[1] = vec4(
						2.0 * (x2 / width) - 1.0,
						2.0 * (y / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[2] = vec4(
						2.0 * (x2 / width) - 1.0,
						2.0 * (y2 / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[3] = vec4(
						2.0 * (x / width) - 1.0,
						2.0 * (y2 / height) - 1.0,
						1.0,
						1.0
						);				
		
		
		for(int i = 0; i < 4; i++)
		{
				
			frustum[i] = invProj * frustum[i];
			frustum[i] /= frustum[i].w;
				
		}
		
		
		frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
		frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
		frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
		frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
		
		//int count = 0;
		
		
		
		
		int i = 0;
		
		int offset = int(cury *( (width/tileWidth) * MAX_LIGHT_PER_TILE) 
				+ curx * MAX_LIGHT_PER_TILE);
		
		for(int j = 0; j < countSub; j++)
		{
		
			int t = j * 256 + int(gl_LocalInvocationID.x);
			if(t >= countSub) break;
			i = indexSub2[offsetSub + t];
			
			
			
			if	(
				
				(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
				&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
				)
				if(zCulling == 1)
				{
					int offsetZB = int(cury*(width/tileWidth) * 2 + curx * 2);
					
					if	(
						(view * vec4(pLight[i].position.xyz,1)).z <= (zB[offsetZB] + pLight[i].position.w)&&
						(view * vec4(pLight[i].position.xyz,1)).z >= (zB[offsetZB+1] - pLight[i].position.w)
						)
					{
						int tempCount = int(atomicAdd(count,1));
						barrier();
						indexB[offset + tempCount] = i;
					
					}
					
				
				
				}
				else
				{
				
							
					int tempCount = int(atomicAdd(count,1));
						barrier();
						indexB[offset + tempCount] = i;		
				
				
				}
			
			
			
		
		
		}
		
	
		if(count > 0)
		{
						 	
			info[(curx + cury * (width/tileWidth)) * 2] = offset; //offset
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = int(count); //
		
		}
		
		else
		{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
		
		}
	}

}



void createFrustumForTileFromSub1()
{
	
	int cury = int(gl_WorkGroupID.y);
	int curx = int(gl_WorkGroupID.x);

	float x = curx * tileWidth ;
	float x2 = x + tileWidth-1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeight  ;
	float y2 = y + tileHeight-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	//what tile
	
	int curySub = int((y2) / tileHeightSub); 
	int curxSub = int((x2) / tileWidthSub);
	
	int offsetSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2];
	int countSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2 + 1];
	
	
	if(offsetSub < 0) 
	{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
	
	}
	else 
	{
		
		
		
		vec4 frustum[4];
		vec4 frustumEq[4];
		
		frustum[0] = vec4(
						2.0 * (x / width) - 1.0,
						2.0 * (y / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[1] = vec4(
						2.0 * (x2 / width) - 1.0,
						2.0 * (y / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[2] = vec4(
						2.0 * (x2 / width) - 1.0,
						2.0 * (y2 / height) - 1.0,
						1.0,
						1.0
						);
						
		frustum[3] = vec4(
						2.0 * (x / width) - 1.0,
						2.0 * (y2 / height) - 1.0,
						1.0,
						1.0
						);				
		
		
		for(int i = 0; i < 4; i++)
		{
				
			frustum[i] = invProj * frustum[i];
			frustum[i] /= frustum[i].w;
				
		}
		
		
		frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
		frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
		frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
		frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
		
	//	int count = 0;
		
		
		
		
		int i = 0;
		
		int offset = cury *( (width/tileWidth) * MAX_LIGHT_PER_TILE) 
				+ curx * MAX_LIGHT_PER_TILE;
		
		for(int j = 0; j < 4; j++)
		{
			int t = j * 256 + int(gl_LocalInvocationID.x);
			if(t >= countSub) break;
			i = indexSub[offsetSub + t];
			
			
			if	(
				
				(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
				&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
				)
				if(zCulling == 1)
				{
					int offsetZB = int(cury*(width/tileWidth) * 2 + curx * 2);
					
					if	(
						(view * vec4(pLight[i].position.xyz,1)).z <= (zB[offsetZB] + pLight[i].position.w)&&
						(view * vec4(pLight[i].position.xyz,1)).z >= (zB[offsetZB+1] - pLight[i].position.w)
						)
					{
						
						int tempCount = int(atomicAdd(count,1));
						barrier();
						indexB[offset + tempCount] = i;
						
					
					}
					
				
				
				}
				else
				{
				
							
					
					int tempCount = int(atomicAdd(count,1));
					barrier();
					indexB[offset + tempCount] = i;
						
				
				
				}
			
			
			
		
		
		}
		
		groupMemoryBarrier();
	
		if(count > 0)
		{
						 	
			info[(curx + cury * (width/tileWidth)) * 2] = offset; //offset
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = int(count); //
		
		}
		
		else
		{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
		
		}
	}

}


















void main()
{


	atomicExchange(count,0);
	
	barrier();

	if(mode == 0)
	{
		createFrustumForTile();
	}
	
	
	
	
	
	//first subdivision
	else if (mode == 1)
	{
		createFrustumForTileSub1();
	}
	
	
	//second subdivision after first
	else if (mode == 2)
	{
		createFrustumForTileSub2after1();
	}
	//read from second subdivision
	else if (mode == 3)
	{
		createFrustumForTileFromSub2();
	}
	
	
	
	
	// read from first subdivision
	else if (mode == 4)
	{
	
	    createFrustumForTileFromSub1();
	
	}
	
	//first subdivision with second's width/height
	else if (mode == 5)
	{
		createFrustumForTileSubWith2();
	}
	
	

}







