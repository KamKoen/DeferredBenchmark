#version 430




layout(std430, binding = 1)  buffer zBuf
{
	float zB[]; //min max
};

layout(std430, binding = 4)  buffer infB
{
	int info[];
};

layout(std430, binding = 5)  buffer indB
{
	int indexB[];
};


layout(std430, binding = 6)  buffer infSubB
{
	int infoSub[];
};

layout(std430, binding = 7)  buffer indSubB
{
	int indexSub[];
};

layout(std430, binding = 2)  buffer infSubB2
{
	int infoSub2[];
};

layout(std430, binding = 3)  buffer indSubB2
{
	int indexSub2[];
};


uniform int zCulling = 0;

uniform int MAX_LIGHT_PER_TILE;
uniform int width;
uniform int height;

uniform int tileWidth;
uniform int tileHeight;

uniform int tileWidthSub;
uniform int tileHeightSub;

uniform int tileWidthSub2;
uniform int tileHeightSub2;

uniform float C;
uniform float D;

uniform int mode;

uniform mat4 invProj;
uniform mat4 view;

struct PointLight{

	vec4 position;	//.w is rad
	vec4 ambient;	//.w ist quad
	vec4 diff;		//.w ist lin
	vec4 specular;	//.w ist const
};

layout (std140) uniform pl{
	
	PointLight pLight[1000];

};


uniform int LIGHT_MAX;

layout(local_size_x = 1,local_size_y = 1,local_size_z = 1) in; 


vec4 createPlaneEq(vec4 a, vec4 b)
{


	vec4 n;
	
	n.xyz = normalize(cross(a.xyz, b.xyz));
	
	n.w = 0;
	
	return n;
	
}


float getSignedDistance(vec4 eqn, vec3 p)
{

	vec4 ret = view * vec4(p,1.0f);
	
	float f = dot(eqn, ret);
	
	return f;

}


float calcViewZ(float z)
{
	float nDcz = z * 2.0f - 1.0f;
	
	float res = -D / (nDcz + C);


	return res;
}







void createFrustumForTile()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;
	
	float x = curx * tileWidth;
	float x2 = x + tileWidth-0.5;
	if(x2 > width-1) x2 = width-0.5;
	
	float y = cury * tileHeight;
	float y2 = y + tileHeight - 0.5;
	if(y2 > height-1) y2 = height-0.5;
	
	vec4 frustum[4];
	vec4 frustumEq[4];
	
	frustum[0] = vec4(
					2.0f * (x / width) - 1.0f,
					2.0f * (y / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[1] = vec4(
					2.0f * (x2 / width) - 1.0f,
					2.0f * (y / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[2] = vec4(
					2.0f * (x2 / width) - 1.0f,
					2.0f * (y2 / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[3] = vec4(
					2.0f * (x / width) - 1.0f,
					2.0f * (y2 / height) - 1.0f,
					1.0f,
					1.0f
					);				
	
	
	for(int i = 0; i < 4; i++)
	{
			
		frustum[i] = invProj * frustum[i];
		frustum[i] /= frustum[i].w;
			
	}
	
	
	frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
	frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
	frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
	frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
	
	int count = 0;
	
	
	
	
	
	
	int offset = int(cury *( (width/tileWidth) * MAX_LIGHT_PER_TILE) 
			+ curx * MAX_LIGHT_PER_TILE);
	
	for(int i = 0; i < LIGHT_MAX; i++)
	{
		
		
		if	(
			
			(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
			&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
			)
			{
				
				if(zCulling == 1)
				{
					int offsetZB = int(cury*(width/tileWidth) * 2 + curx * 2);
					
					if	(
						(view * vec4(pLight[i].position.xyz,1)).z <= (zB[offsetZB] + pLight[i].position.w)&&
						(view * vec4(pLight[i].position.xyz,1)).z >= (zB[offsetZB+1] - pLight[i].position.w)
						)
					{
						indexB[offset + count] = i;
						count += 1;
					
					}
					
				
				
				}
				else
				{
				
							
					indexB[offset + count] = i;
					count += 1;		
				
				
				}
			}
		
		
		
	
	
	}
	

	if(count > 0)
	{
					 	
		info[(curx + cury * (width/tileWidth)) * 2] = offset; //offset
		info[(curx + cury * (width/tileWidth)) * 2 + 1] = count; //
	
	}
	
	else
	{
		info[(curx + cury * (width/tileWidth)) * 2] = -1;
		info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
	
	}
	

}































void createFrustumForTileSub1() //mode 1
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidthSub;
	float x2 = x + tileWidthSub -1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeightSub;
	float y2 = y + tileHeightSub-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	
	vec4 frustum[4];
	vec4 frustumEq[4];
	
	frustum[0] = vec4(
					2.0f * (x / width) - 1.0f,
					2.0f * (y / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[1] = vec4(
					2.0f * (x2 / width) - 1.0f,
					2.0f * (y / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[2] = vec4(
					2.0f * (x2 / width) - 1.0f,
					2.0f * (y2 / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[3] = vec4(
					2.0f * (x / width) - 1.0f,
					2.0f * (y2 / height) - 1.0f,
					1.0f,
					1.0f
					);				
	
	
	for(int i = 0; i < 4; i++)
	{
			
		frustum[i] = invProj * frustum[i];
		frustum[i] /= frustum[i].w;
			
	}
	
	
	frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
	frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
	frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
	frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
	
	int count = 0;
	
	
	
	
	
	
	int offset = int(cury *( (width/tileWidthSub) * MAX_LIGHT_PER_TILE) 
			+ curx * MAX_LIGHT_PER_TILE);
	
	for(int i = 0; i < LIGHT_MAX; i++)
	{
		
		
		if	(
			
			(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
			&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
			
			)
			{
			
				
							
					indexSub[offset + count] = i;
					count += 1;		
				
				
				
			
			
			}
		
		
		
	
	
	}
	

	if(count > 0)
	{
					 	
		infoSub[(curx + cury * (width/tileWidthSub)) * 2] = offset; //offset
		infoSub[(curx + cury * (width/tileWidthSub)) * 2 + 1] = count; //
	
	}
	
	else
	{
		infoSub[(curx + cury * (width/tileWidthSub)) * 2] = -1;
		infoSub[(curx + cury * (width/tileWidthSub)) * 2 + 1] = -1;
	
	}
	

}



void createFrustumForTileSubWith2()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidthSub2;
	float x2 = x + tileWidthSub2-1;
	if(x2 > width -1) x2 = width -1;
	
	float y = cury * tileHeightSub2;
	float y2 = y + tileHeightSub2-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	
	vec4 frustum[4];
	vec4 frustumEq[4];
	
	frustum[0] = vec4(
					2.0f * (x / width) - 1.0f,
					2.0f * (y / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[1] = vec4(
					2.0f * (x2 / width) - 1.0f,
					2.0f * (y / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[2] = vec4(
					2.0f * (x2 / width) - 1.0f,
					2.0f * (y2 / height) - 1.0f,
					1.0f,
					1.0f
					);
					
	frustum[3] = vec4(
					2.0f * (x / width) - 1.0f,
					2.0f * (y2 / height) - 1.0f,
					1.0f,
					1.0f
					);				
	
	
	for(int i = 0; i < 4; i++)
	{
			
		frustum[i] = invProj * frustum[i];
		frustum[i] /= frustum[i].w;
			
	}
	
	
	frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
	frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
	frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
	frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
	
	int count = 0;
	
	
	
	
	
	
	int offset = int(cury *( (width/tileWidthSub2) * MAX_LIGHT_PER_TILE) 
			+ curx * MAX_LIGHT_PER_TILE);
	
	for(int i = 0; i < LIGHT_MAX; i++)
	{
		
		
		if	(
			
			(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
			(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
			&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
			)
			{
							
				indexSub2[offset + count] = i;
				count += 1;		
			}
		
		
		
	
	
	}
	

	if(count > 0)
	{
					 	
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = offset; //offset
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = count; //
	
	}
	
	else
	{
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
		infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
	
	}
	

}




void createFrustumForTileSub2after1()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidthSub2;
	float x2 = x + tileWidthSub2 - 1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeightSub2;
	float y2 = y + tileHeightSub2 - 1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	//what tile
	
	int curySub = int(y2 / tileHeightSub);
	int curxSub = int(x2 / tileWidthSub);
	
	int offsetSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2];
	int countSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2 + 1];
	
	if(offsetSub < 0) 
	{
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
	
	}
	else 
	{
		
		
		
		vec4 frustum[4];
		vec4 frustumEq[4];
		
		frustum[0] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[1] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[2] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[3] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);				
		
		
		for(int i = 0; i < 4; i++)
		{
				
			frustum[i] = invProj * frustum[i];
			frustum[i] /= frustum[i].w;
				
		}
		
		
		frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
		frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
		frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
		frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
		
		int count = 0;
		
		
		
		
		int i = 0;
		
		int offset = int(cury *( (width/tileWidthSub2) * MAX_LIGHT_PER_TILE) 
				+ curx * MAX_LIGHT_PER_TILE);
		
		for(int j = 0; j < countSub; j++)
		{
			i = indexSub[offsetSub + j];
			
			
			if	(
				
				(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w)  
				&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
				)
				{
								
					indexSub2[offset + count] = i;
					count += 1;		
				}
			
			
			
		
		
		}
		
	
		if(count > 0)
		{
						 	
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = offset; //offset
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = count; //
		
		}
		
		else
		{
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
		
		}
	}

}


void createFrustumForTileSub2after1SAFE()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidthSub2;
	float x2 = x + tileWidthSub2;
	if(x2 > width) x2 = width;
	
	float y = cury * tileHeightSub2;
	float y2 = y + tileHeightSub2;
	if(y2 > height) y2 = height;
	
	
	
	//what tile
	
	int curySub = int((y+1) / tileHeightSub);
	int curxSub = int((x) / tileWidthSub);
	
	int offsetSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2];
	int countSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2 + 1];
	
	if(offsetSub < 0) 
	{
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
	
	}
	else 
	{
		
		
		
		vec4 frustum[4];
		vec4 frustumEq[4];
		
		frustum[0] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[1] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[2] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[3] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);				
		
		
		for(int i = 0; i < 4; i++)
		{
				
			frustum[i] = invProj * frustum[i];
			frustum[i] /= frustum[i].w;
				
		}
		
		
		frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
		frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
		frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
		frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
		
		int count = 0;
		
		
		
		
		int i = 0;
		
		int offset = int(cury *( (width/tileWidthSub2) * MAX_LIGHT_PER_TILE) 
				+ curx * MAX_LIGHT_PER_TILE);
		
		for(int j = 0; j < countSub; j++)
		{
			i = indexSub[offsetSub + j];
			
			
			if	(
				
				(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
				&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
				)
				{
								
					indexSub2[offset + count] = i;
					count += 1;		
				}
			
			
			
		
		
		}
		
	
		if(count > 0)
		{
						 	
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = offset; //offset
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = count; //
		
		}
		
		else
		{
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2] = -1;
			infoSub2[(curx + cury * (width/tileWidthSub2)) * 2 + 1] = -1;
		
		}
	}

}





void createFrustumForTileFromSub2()
{
	
	uint cury = gl_WorkGroupID.y;
	uint curx = gl_WorkGroupID.x;

	float x = curx * tileWidth;
	float x2 = x + tileWidth-1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeight;
	float y2 = y + tileHeight-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	//what tile
	
	int curySub = int(y2 / tileHeightSub2);
	int curxSub = int(x2 / tileWidthSub2);
	
	int offsetSub = infoSub2[(curxSub + curySub * (width / tileWidthSub2)) * 2];
	int countSub = infoSub2[(curxSub + curySub * (width / tileWidthSub2)) * 2 + 1];
	
	if(offsetSub < 0) 
	{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
	
	}
	else 
	{
		
		
		
		vec4 frustum[4];
		vec4 frustumEq[4];
		
		frustum[0] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[1] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[2] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[3] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);				
		
		
		for(int i = 0; i < 4; i++)
		{
				
			frustum[i] = invProj * frustum[i];
			frustum[i] /= frustum[i].w;
				
		}
		
		
		frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
		frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
		frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
		frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
		
		int count = 0;
		
		
		
		
		int i = 0;
		
		int offset = int(cury *( (width/tileWidth) * MAX_LIGHT_PER_TILE) 
				+ curx * MAX_LIGHT_PER_TILE);
		
		for(int j = 0; j < countSub; j++)
		{
			i = indexSub2[offsetSub + j];
			
			
			if	(
				
				(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
				&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
				)
				if(zCulling == 1)
				{
					int offsetZB = int(cury*(width/tileWidth) * 2 + curx * 2);
					
					if	(
						(view * vec4(pLight[i].position.xyz,1)).z <= (zB[offsetZB] + pLight[i].position.w)&&
						(view * vec4(pLight[i].position.xyz,1)).z >= (zB[offsetZB+1] - pLight[i].position.w)
						)
					{
						indexB[offset + count] = i;
						count += 1;
					
					}
					
				
				
				}
				else
				{
				
							
					indexB[offset + count] = i;
					count += 1;		
				
				
				}
			
			
			
		
		
		}
		
	
		if(count > 0)
		{
						 	
			info[(curx + cury * (width/tileWidth)) * 2] = offset; //offset
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = count; //
		
		}
		
		else
		{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
		
		}
	}

}



void createFrustumForTileFromSub1()
{
	
	int cury = int(gl_WorkGroupID.y);
	int curx = int(gl_WorkGroupID.x);

	float x = curx * tileWidth ;
	float x2 = x + tileWidth-1;
	if(x2 > width-1) x2 = width-1;
	
	float y = cury * tileHeight  ;
	float y2 = y + tileHeight-1;
	if(y2 > height-1) y2 = height-1;
	
	
	
	//what tile
	
	int curySub = int((y2) / tileHeightSub); //IDFK WHY
	int curxSub = int((x2) / tileWidthSub);
	
	int offsetSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2];
	int countSub = infoSub[(curxSub + curySub * (width / tileWidthSub)) * 2 + 1];
	
	if(offsetSub < 0) 
	{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
	
	}
	else 
	{
		
		
		
		vec4 frustum[4];
		vec4 frustumEq[4];
		
		frustum[0] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[1] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[2] = vec4(
						2.0f * (x2 / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);
						
		frustum[3] = vec4(
						2.0f * (x / width) - 1.0f,
						2.0f * (y2 / height) - 1.0f,
						1.0f,
						1.0f
						);				
		
		
		for(int i = 0; i < 4; i++)
		{
				
			frustum[i] = invProj * frustum[i];
			frustum[i] /= frustum[i].w;
				
		}
		
		
		frustumEq[0] = createPlaneEq(frustum[0], frustum[1]);
		frustumEq[1] = createPlaneEq(frustum[1], frustum[2]);
		frustumEq[2] = createPlaneEq(frustum[2], frustum[3]);
		frustumEq[3] = createPlaneEq(frustum[3], frustum[0]);
		
		int count = 0;
		
		
		
		
		int i = 0;
		
		int offset = cury *( (width/tileWidth) * MAX_LIGHT_PER_TILE) 
				+ curx * MAX_LIGHT_PER_TILE;
		
		for(int j = 0; j < countSub; j++)
		{
			i = indexSub[offsetSub + j];
			
			
			if	(
				
				(getSignedDistance(frustumEq[0], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[1], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[2], pLight[i].position.xyz) < pLight[i].position.w) &&
				(getSignedDistance(frustumEq[3], pLight[i].position.xyz) < pLight[i].position.w) 
				&& ((view * vec4(pLight[i].position.xyz,1)).z <= (0 + pLight[i].position.w))
				)
				if(zCulling == 1)
				{
					int offsetZB = int(cury*(width/tileWidth) * 2 + curx * 2);
					
					if	(
						(view * vec4(pLight[i].position.xyz,1)).z <= (zB[offsetZB] + pLight[i].position.w)&&
						(view * vec4(pLight[i].position.xyz,1)).z >= (zB[offsetZB+1] - pLight[i].position.w)
						)
					{
						indexB[offset + count] = i;
						count += 1;
					
					}
					
				
				
				}
				else
				{
				
							
					indexB[offset + count] = i;
					count += 1;		
				
				
				}
			
			
			
		
		
		}
		
	
		if(count > 0)
		{
						 	
			info[(curx + cury * (width/tileWidth)) * 2] = offset; //offset
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = count; //
		
		}
		
		else
		{
			info[(curx + cury * (width/tileWidth)) * 2] = -1;
			info[(curx + cury * (width/tileWidth)) * 2 + 1] = -1;
		
		}
	}

}


void main()
{
	if(mode == 0)
	{
		createFrustumForTile();
	}
	
	
	
	
	
	//first subdivision
	else if (mode == 1)
	{
		createFrustumForTileSub1();
	}
	
	
	//second subdivision after first
	else if (mode == 2)
	{
		createFrustumForTileSub2after1();
	}
	//read from second subdivision
	else if (mode == 3)
	{
		createFrustumForTileFromSub2();
	}
	
	
	
	
	// read from first subdivision
	else if (mode == 4)
	{
	
	    createFrustumForTileFromSub1();
	
	}
	
	//first subdivision with second's width/height
	else if (mode == 5)
	{
		createFrustumForTileSubWith2();
	}
	
	barrier();
}







